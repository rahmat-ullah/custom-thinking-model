import unittest
from unittest.mock import patch, MagicMock, ANY

# Add the project root to the Python path to allow importing app
import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import functions to be tested from app.py
from app import process_voice_command, process_email_command_text, handle_submit 

# Mock streamlit before it's imported by app
# This is a common pattern for testing Streamlit apps
mock_st = MagicMock()
sys.modules['streamlit'] = mock_st
sys.modules['audio_utils'] = MagicMock()
sys.modules['email_utils'] = MagicMock()
sys.modules['config'] = MagicMock() 
sys.modules['config'].ENABLE_LOGGING = False # Disable logging for tests

# Mock the DirectChat and ThinkingChat if they are globally initialized or accessed
# For now, we'll mock them where they are used if possible, or globally if app.py structure requires
sys.modules['direct_chat'] = MagicMock()
sys.modules['thinking_chat'] = MagicMock()


class TestEmailProcessing(unittest.TestCase):

    def setUp(self):
        # Reset mocks and session_state for each test
        mock_st.reset_mock()
        
        # Mock st.session_state as a dictionary
        self.mock_session_state = {}
        mock_st.session_state = self.mock_session_state
        
        # Mock VoiceEmailHandler
        self.mock_voice_email_handler = MagicMock()
        self.mock_voice_email_handler.current_email_id = None # Default
        self.mock_session_state['voice_email_handler'] = self.mock_voice_email_handler
        
        # Mock DirectChat instance if accessed via session_state or globally
        self.mock_direct_chat_instance = MagicMock()
        # If DirectChat is instantiated in app.py like st.session_state.direct_chat = DirectChat()
        # we need to ensure that st.session_state.direct_chat points to our mock
        self.mock_session_state['direct_chat'] = self.mock_direct_chat_instance

        # Mock audio_utils specifically for speak_text
        self.mock_audio_utils_speak_text = MagicMock()
        audio_utils_module = sys.modules['audio_utils']
        audio_utils_module.speak_text = self.mock_audio_utils_speak_text

        # Default states
        self.mock_session_state['talking_mode_enabled'] = False
        self.mock_session_state['waiting_for_reply_body'] = False # For voice
        self.mock_session_state['waiting_for_text_reply_body'] = False # For text
        self.mock_session_state['user_input'] = ""
        self.mock_session_state['selected_tts_voice'] = "alloy" # Default voice for tests


    # --- Tests for process_voice_command ---

    def test_pvc_fetch_unread_default_max_results(self):
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "Fetched 5 emails."
        process_voice_command("fetch unread email")
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=5)
        self.mock_audio_utils_speak_text.assert_called_with("Fetched 5 emails.", voice_id="alloy")

    def test_pvc_fetch_unread_with_number(self):
        # This test doesn't check speak_text directly, but ensures the command is processed.
        # speak_text would be called if a response_text is generated by the handler.
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "Fetched 7 emails."
        process_voice_command("fetch 7 unread emails")
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=7)

    def test_pvc_fetch_unread_with_number_word(self):
        process_voice_command("get my last three emails")
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=3)

    def test_pvc_fetch_unread_with_number_word_in_phrase(self):
        process_voice_command("check my email and get the last one") # "one" should be parsed
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=1)

    def test_pvc_read_email_by_number(self):
        self.mock_voice_email_handler.read_email_voice.return_value = "Reading email 2."
        process_voice_command("read email number 2")
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("2")
        self.mock_audio_utils_speak_text.assert_called_with("Reading email 2.", voice_id="alloy")

    def test_pvc_read_email_by_number_word_first(self):
        # This test doesn't check speak_text, focuses on identifier parsing.
        process_voice_command("read the first email")
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("1")
        
    def test_pvc_read_email_by_number_word_three(self):
        # Test "open email three" to ensure "open" synonym and number word "three" work
        process_voice_command("open email three")
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("3")

    def test_pvc_read_email_by_subject(self):
        process_voice_command("read email with subject meeting notes")
        # Current logic: identifier_part.split("subject",1)[-1].strip()
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("meeting notes")

    def test_pvc_read_email_by_sender(self):
        process_voice_command("read email from John Doe")
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("John Doe")

    def test_pvc_read_email_empty_identifier(self):
        process_voice_command("read email")
        self.mock_voice_email_handler.read_email_voice.assert_not_called()
        self.mock_audio_utils_speak_text.assert_called_with(
            "Please specify which email to read, for example, 'read email number one' or 'read email from Jane'.",
            voice_id="alloy"
        )
        
    def test_pvc_reply_initiates_waiting_for_reply_body(self):
        self.mock_voice_email_handler.current_email_id = "email123"
        process_voice_command("reply to this email")
        self.assertTrue(self.mock_session_state['waiting_for_reply_body'])
        self.mock_audio_utils_speak_text.assert_called_with("What would you like to say in your reply?", voice_id="alloy")

    def test_pvc_reply_body_processed(self):
        self.mock_session_state['waiting_for_reply_body'] = True
        self.mock_voice_email_handler.current_email_id = "email123"
        self.mock_voice_email_handler.prepare_reply_voice.return_value = "Reply sent."
        
        process_voice_command("This is my reply message.")
        
        self.assertFalse(self.mock_session_state['waiting_for_reply_body'])
        self.mock_voice_email_handler.prepare_reply_voice.assert_called_once_with("This is my reply message.")
        self.mock_audio_utils_speak_text.assert_called_with("Reply sent.", voice_id="alloy")

    @patch('app.process_general_llm_input')
    def test_pvc_no_handler_email_command(self, mock_process_general_llm_input):
        self.mock_session_state['voice_email_handler'] = None
        recognized_text = "check my email"
        process_voice_command(recognized_text)
        self.mock_audio_utils_speak_text.assert_called_once_with(
            "To use email commands, please first connect to Gmail using the button in the user interface.",
            voice_id="alloy"
        )
        mock_process_general_llm_input.assert_not_called()

    @patch('app.process_general_llm_input')
    def test_pvc_non_email_command_calls_general_llm_with_voice_id(self, mock_process_general_llm_input):
        # This test assumes process_general_llm_input will call speak_text
        # We need to mock process_general_llm_input to not call the real one, but verify app.py calls it.
        # The speak_text call inside process_general_llm_input will use the session_state voice.
        # So, we set it here and expect app.py to pass it.
        # Note: This specific test in `test_app_email_processing.py` is testing the routing logic of `process_voice_command`.
        # The actual call to `speak_text` with `voice_id` from `process_general_llm_input` would be better tested
        # if `process_general_llm_input` itself had dedicated tests or if we patch `audio_utils.speak_text`
        # directly for calls made *from* `process_general_llm_input`.
        # For now, we assert that `process_general_llm_input` is called. If `talking_mode_enabled` is true
        # *inside* `process_general_llm_input`, it *should* use the `selected_tts_voice`.
        
        self.mock_session_state['talking_mode_enabled'] = True # Crucial for speak_text in general_llm
        self.mock_session_state['selected_tts_voice'] = "nova"
        recognized_text = "what is the weather today"
        
        # To properly test the voice_id from process_general_llm_input, we'd need to
        # let process_general_llm_input run but patch speak_text.
        # Let's adjust the patch for this specific test.
        with patch('app.audio_utils.speak_text') as mock_speak_within_general_llm:
            process_voice_command(recognized_text) # This calls process_general_llm_input

            # Check that process_general_llm_input was called
            mock_process_general_llm_input.assert_called_once_with(recognized_text, called_from_voice=True)
            
            # To verify the voice_id used by process_general_llm_input, we need to inspect
            # calls to the speak_text it contains. This is tricky because process_general_llm_input
            # is already mocked by the decorator.
            # A better approach for testing process_general_llm_input's voice usage would be separate tests for it.
            # For THIS test (pvc_non_email_command_calls_general_llm), the primary check is the call to general_llm.
            # The provided solution structure makes it hard to test voice_id from a mocked process_general_llm_input.
            # We will assume that if process_general_llm_input is called, and talking mode is on,
            # it internally respects selected_tts_voice.
            # The existing mock_process_general_llm_input.assert_called_once_with is the main check here.
            # If process_general_llm_input *itself* was to be tested for voice_id, it would be:
            #   mock_speak_within_general_llm.assert_called_with(ANY, voice_id="nova")
            # but this current test is for process_voice_command's routing.

        self.assertEqual(self.mock_session_state['user_input'], recognized_text)


    # --- Tests for process_email_command_text ---

    def test_pect_fetch_unread_default_max_results(self):
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "5 emails fetched."
        response = process_email_command_text("fetch unread email", self.mock_voice_email_handler)
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=5)
        self.assertEqual(response, "5 emails fetched.")

    def test_pect_fetch_unread_with_number(self):
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "7 emails fetched."
        response = process_email_command_text("fetch 7 unread emails", self.mock_voice_email_handler)
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=7)
        self.assertEqual(response, "7 emails fetched.")

    def test_pect_fetch_unread_with_number_word(self):
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "Three emails fetched."
        response = process_email_command_text("get my last three emails", self.mock_voice_email_handler)
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=3)
        self.assertEqual(response, "Three emails fetched.")

    def test_pect_read_email_by_number(self):
        self.mock_voice_email_handler.read_email_voice.return_value = "Email content for 2."
        response = process_email_command_text("read email 2", self.mock_voice_email_handler)
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("2")
        self.assertEqual(response, "Email content for 2.")

    def test_pect_read_email_by_number_word(self):
        self.mock_voice_email_handler.read_email_voice.return_value = "Email content for first."
        response = process_email_command_text("read the first email", self.mock_voice_email_handler)
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("1") 
        self.assertEqual(response, "Email content for first.")

    def test_pect_read_email_by_subject(self):
        self.mock_voice_email_handler.read_email_voice.return_value = "Email content for meeting notes."
        response = process_email_command_text("read email with subject meeting notes", self.mock_voice_email_handler)
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("meeting notes")
        self.assertEqual(response, "Email content for meeting notes.")

    def test_pect_read_email_by_sender(self):
        self.mock_voice_email_handler.read_email_voice.return_value = "Email content from John Doe."
        response = process_email_command_text("read email from John Doe", self.mock_voice_email_handler)
        self.mock_voice_email_handler.read_email_voice.assert_called_once_with("John Doe")
        self.assertEqual(response, "Email content from John Doe.")
        
    def test_pect_read_email_empty_identifier(self):
        response = process_email_command_text("read email", self.mock_voice_email_handler)
        self.mock_voice_email_handler.read_email_voice.assert_not_called()
        self.assertEqual(response, "Please specify which email to read, for example, 'read email number one' or 'read email from Jane'.")

    def test_pect_reply_initiates_waiting_for_text_reply_body(self):
        self.mock_voice_email_handler.current_email_id = "email456"
        response = process_email_command_text("reply to this email", self.mock_voice_email_handler)
        self.assertTrue(self.mock_session_state['waiting_for_text_reply_body'])
        self.assertEqual(response, "What would you like to say in your reply? Please type your message.")
        
    def test_pect_reply_no_current_email(self):
        self.mock_voice_email_handler.current_email_id = None # No email selected/read
        response = process_email_command_text("reply email", self.mock_voice_email_handler)
        self.assertFalse(self.mock_session_state['waiting_for_text_reply_body'])
        self.assertEqual(response, "Please read an email first before replying via text.")

    def test_pect_no_handler_returns_none(self):
        response = process_email_command_text("some random text", None) # No handler
        self.assertIsNone(response)

    def test_pect_non_email_command_returns_none(self):
        response = process_email_command_text("this is not an email command", self.mock_voice_email_handler)
        self.assertIsNone(response)
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_not_called()
        self.mock_voice_email_handler.read_email_voice.assert_not_called()


    # --- Tests for handle_submit ---
    @patch('app.process_general_llm_input') 
    def test_hs_email_command_fetch(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "fetch 10 unread emails"
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "Fetched 10 emails."
        
        handle_submit()
        
        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=10)
        self.mock_direct_chat_instance.add_message.assert_any_call("user", "fetch 10 unread emails")
        self.mock_direct_chat_instance.add_message.assert_any_call("assistant", "Fetched 10 emails.")
        self.assertEqual(self.mock_session_state['user_input'], "") 
        mock_process_general_llm_input.assert_not_called()
        mock_st.rerun.assert_called_once()


    @patch('app.process_general_llm_input')
    def test_hs_email_command_fetch_with_talking_mode_and_specific_voice(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "fetch unread emails"
        self.mock_session_state['talking_mode_enabled'] = True
        self.mock_session_state['selected_tts_voice'] = "nova" # Specific voice
        self.mock_voice_email_handler.fetch_unread_emails_voice.return_value = "Fetched emails."

        handle_submit()

        self.mock_voice_email_handler.fetch_unread_emails_voice.assert_called_once_with(max_results=5)
        self.mock_direct_chat_instance.add_message.assert_any_call("user", "fetch unread emails")
        self.mock_direct_chat_instance.add_message.assert_any_call("assistant", "Fetched emails.")
        self.mock_audio_utils_speak_text.assert_called_once_with("Fetched emails.", voice_id="nova")
        mock_process_general_llm_input.assert_not_called()
        mock_st.rerun.assert_called_once()

    @patch('app.process_general_llm_input')
    def test_hs_text_reply_body_processing_default_voice(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "This is my detailed reply."
        self.mock_session_state['waiting_for_text_reply_body'] = True
        self.mock_voice_email_handler.current_email_id = "email789"
        self.mock_voice_email_handler.prepare_reply_voice.return_value = "Text reply sent successfully."

        handle_submit()

        self.mock_voice_email_handler.prepare_reply_voice.assert_called_once_with("This is my detailed reply.")
        self.assertFalse(self.mock_session_state['waiting_for_text_reply_body'])
        self.mock_direct_chat_instance.add_message.assert_any_call("user", "This is my detailed reply.")
        self.mock_direct_chat_instance.add_message.assert_any_call("assistant", "Text reply sent successfully.")
        mock_process_general_llm_input.assert_not_called()
        mock_st.rerun.assert_called_once()

    @patch('app.process_general_llm_input')
    def test_hs_text_reply_body_with_talking_mode_and_shimmer_voice(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "Okay, send it."
        self.mock_session_state['waiting_for_text_reply_body'] = True
        self.mock_session_state['talking_mode_enabled'] = True
        self.mock_session_state['selected_tts_voice'] = "shimmer" # Specific voice
        self.mock_voice_email_handler.current_email_id = "email789"
        self.mock_voice_email_handler.prepare_reply_voice.return_value = "Message sent."

        handle_submit()
        self.mock_audio_utils_speak_text.assert_called_once_with("Message sent.", voice_id="shimmer")
        mock_process_general_llm_input.assert_not_called()

    @patch('app.process_general_llm_input')
    # Test for process_general_llm_input being called and potentially using voice
    @patch('app.audio_utils.speak_text') # Patch speak_text specifically for this test of process_general_llm_input path
    def test_hs_non_email_command_falls_through_with_voice(self, mock_speak_text_for_general, mock_process_general_llm_input_passthrough):
        # We want process_general_llm_input to actually run to see if it calls speak_text
        # So we use a passthrough for mock_process_general_llm_input_passthrough
        # The decorator @patch('app.process_general_llm_input') will be mock_process_general_llm_input_passthrough
        # The decorator @patch('app.audio_utils.speak_text') will be mock_speak_text_for_general
        
        # Configure the passthrough mock to call the original function
        # This requires getting a reference to the original function *before* it's patched by the class decorator
        # This is complex. A simpler way is to test process_general_llm_input separately.
        # Given the current structure, let's assume process_general_llm_input correctly uses voice_id if talking_mode_enabled.
        # The test below simplifies to ensure routing and that speak_text is NOT called directly by handle_submit for non-email commands.
        
        self.mock_session_state['user_input'] = "Tell me a joke."
        self.mock_session_state['talking_mode_enabled'] = True # Talking mode is on
        self.mock_session_state['selected_tts_voice'] = "echo"
        
        # We are primarily testing that handle_submit routes to process_general_llm_input
        # and does NOT call speak_text itself for this case.
        # The mock_process_general_llm_input_passthrough is the one from the first decorator.
        handle_submit() 

        mock_process_general_llm_input_passthrough.assert_called_once_with("Tell me a joke.", called_from_voice=False)
        self.mock_direct_chat_instance.add_message.assert_not_called() 
        
        # Assert that audio_utils.speak_text (the one from setUp) was NOT called directly by handle_submit
        self.mock_audio_utils_speak_text.assert_not_called() 
        
        # If we wanted to assert that the speak_text *inside* process_general_llm_input was called with "echo",
        # we would need a different test structure, likely focused on process_general_llm_input itself.
        # For example:
        # original_process_general_llm = app.process_general_llm_input 
        # with patch('app.audio_utils.speak_text') as specific_speak_mock:
        #     original_process_general_llm("Tell me a joke", called_from_voice=False)
        #     if self.mock_session_state['talking_mode_enabled']:
        #          specific_speak_mock.assert_called_with(ANY, voice_id="echo")


    @patch('app.process_general_llm_input')
    def test_hs_non_email_command_falls_through(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "Tell me a joke."
        
        handle_submit() 

        mock_process_general_llm_input.assert_called_once_with("Tell me a joke.", called_from_voice=False)
        self.mock_direct_chat_instance.add_message.assert_not_called() 
        self.mock_audio_utils_speak_text.assert_not_called()


    @patch('app.process_general_llm_input')
    def test_hs_no_input_does_nothing(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "" # Blank input
        handle_submit()
        mock_process_general_llm_input.assert_not_called()
        self.mock_direct_chat_instance.add_message.assert_not_called()
        mock_st.rerun.assert_not_called() 

    @patch('app.process_general_llm_input')
    def test_hs_email_command_no_handler(self, mock_process_general_llm_input):
        self.mock_session_state['user_input'] = "fetch my emails"
        self.mock_session_state['voice_email_handler'] = None # No handler
        
        handle_submit()
        
        mock_process_general_llm_input.assert_called_once_with("fetch my emails", called_from_voice=False)
        self.mock_direct_chat_instance.add_message.assert_not_called()


if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
